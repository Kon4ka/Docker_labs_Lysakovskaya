# Лабораторная работа 3: Multistage сборка в Java

## Команды для выполнения лабораторной работы

~~~sh
# Скачиваем базовый образ для сборки
docker pull maven:3.8.4-openjdk-11

# Создаём образ с multistage сборкой
docker build . -f Dockerfile_multistage -t multistage_image:1

# Выводим список образов
docker image list
~~~

Пример вывода:
~~~
maven                               3.8.4-openjdk-11   4b82a5896571   3 years ago      1.04GB
multistage_image                    1                  d3248c0cb8e9   3 minutes ago    321MB
~~~

### Разница в размерах образов:
- `maven:3.8.4-openjdk-11` — **1.04GB**
- `multistage_image:1` — **321MB**
- **Снижение размера почти в три раза!**

---

## Разбор разницы между традиционной и multistage сборкой

В лабораторной работе 1 использовался стандартный подход:
- Приложение собиралось в контейнере с Maven и JDK, и итоговый образ включал все зависимости и инструменты разработки. Это приводило к значительному увеличению размера.

В лабораторной работе 3 применяется **multistage сборка**, которая позволяет значительно сократить размер финального контейнера:
- **Этап сборки (builder):**
  - Используется образ `maven:3.8.4-openjdk-11`, в котором происходит скачивание зависимостей и компиляция исходного кода.
  - Создаётся JAR-файл с готовым приложением.
- **Этап выполнения:**
  - Используется `gcr.io/distroless/java:11`, который не содержит ничего лишнего.
  - В контейнер копируется только готовый JAR-файл.
  
### Преимущества multistage подхода:
- **Значительное уменьшение размера образа.** Исключаем компиляторы, сборщики и временные файлы.
- **Более быстрая сборка и развертывание.** Легковесный образ загружается быстрее.
- **Повышенная безопасность.** В финальном контейнере нет инструментов разработки, что снижает возможные уязвимости.

---

Таким образом, использование **multistage сборки** позволяет добиться **оптимального размера контейнера без потери функциональности**, что критично для production-окружений.

